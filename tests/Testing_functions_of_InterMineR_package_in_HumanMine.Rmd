---
title: "Testing functions of InterMineR package in HumanMine"
author: "Konstantinos Kyritsis"
date: "14 May 2017"
output: 
  pdf_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Testing query functions of InterMineR package in HumanMine

In this .html file generated using Rmarkdown and knitr package, the functions of InterMineR package, which are described in the GitHub repo "intermineR/inst/doc/InterMineR.pdf", are applied in order to check their proper functionality. 

```{r load_template_queries_run}
# load InterMineR package
library(InterMineR)

# Initialize the list containing the base URL and API token (HumanMine)
im <- initInterMine(mine=listMines()["HumanMine"])

# Get template (collection of pre-defined queries)
template = getTemplates(im)
head(template)

# Query for gene orthologs
queryGeneOrth = getTemplateQuery(
  im = im, 
  name = "Gene_Orth"
)

# Run query
resGeneOrth <- runQuery(im, queryGeneOrth)
head(resGeneOrth)

# Look at data model
model = try(getModel(im = im))

# getModel function faces a problem in listModelSummary function
model

```

Besides the getModel function, calling the InterMineR package, loading HumanMine, getting templates and template queries and running a query seem to work properly.

## Small addition in listModelSummary function

By adding the following line of code in listModelSummary function:

att.ext = att.ext[,1:3]

which is executed during the getModel function, one can obtain the model for HumanMine and continue to check the rest of InterMineR functions:

```{r load_required_packages, warning=FALSE, message=FALSE}

library(RJSONIO)
library(httr)
library(sqldf)
library(igraph)

```


```{r modified_listModelSummary}

getModel.modified <- function(im, timeout=3){
  r <- GET(paste(im$mine, "/service/model", sep=""))
  stop_for_status(r)
  model.string <- content(r, "text")
  model <- fromJSON(model.string)$model$classes
  res <- listModelSummary.modified(model)
  res
}

listModelSummary.modified <- function(model){
  class.name <- names(model)
  class.parent <- lapply(class.name, function(x) {
    y <- model[[x]][["extends"]]
    if(is.list(y)){
      y <- NA
    }
    y
  })
  
  class.name <- rep(class.name, sapply(class.parent, length))
  class.parent <- unlist(class.parent)
  igr <- graph.data.frame(data.frame(
    parent=class.parent[which(!is.na(class.parent))],
    name=class.name[which(!is.na(class.parent))]),
    vertices=data.frame(unique(c(class.name,
                                 class.parent[which(!is.na(class.parent))]))))
  
  igr.sp <- shortest.paths(igr, mode="in")
  att <- lapply(class.name, function(x) data.frame(do.call(rbind,
                                                           model[[x]][["attributes"]]), stringsAsFactors=FALSE))
  names(att) <- class.name
  
  att.ext <- rep(list(NULL), length(class.name))
  att.ext <- lapply(class.name, function(x){
    ext <- colnames(igr.sp)[which(is.finite(igr.sp[x, ]))]
    
    y <- unique(do.call(rbind, att[ext]))
    y <- cbind(class=rep(x, nrow(y)), y, stringsAsFactors=FALSE)
    colnames(y) <- c("type", "child_name", "child_type")
    y <- y[order(y$child_name),, drop=FALSE]
    rownames(y) <- NULL
    y
  })
  att.ext <- do.call(rbind, att.ext)
  att.ext$child_type <- ""
  rownames(att.ext) <- NULL
  
  #
  
  # Error occuring when using HumanMine:
  # The fourth column of the att.ext variable is redundant and will prevent the
  # rbind(att.ext, ref.ext, col.ext) below!!!
  
  # columns 2 and 4 contain identical information
  all(tolower(att.ext[,2]) %in% gsub(" ", "", tolower(att.ext[,4])))
  
  # Therefore, we keep only the first 3 columns from the att.ext variable:
  att.ext = att.ext[,1:3]
  
  #
  
  ref <- lapply(class.name, function(x) {
    y <- model[[x]][["references"]]
    if(length(y)==0){
      z <- data.frame(matrix(character(0), 0, 2, dimnames=list(NULL,
                                                               c("name", "referencedType"))))
    } else {
      z1 <- names(y)
      z2 <- sapply(y, function(ye)
        ye[["referencedType"]])
      z <- data.frame(name=z1, referencedType=z2)
    }
    z
  })
  names(ref) <- class.name
  
  ref.ext <- rep(list(NULL), length(class.name))
  
  ref.ext <- lapply(class.name, function(x) {
    ext <- colnames(igr.sp)[which(is.finite(igr.sp[x, ]))]
    y <- unique(do.call(rbind, ref[ext]))
    y <- cbind(class=rep(x, nrow(y)), y, stringsAsFactors=FALSE)
    colnames(y) <- c("type", "child_name", "child_type")
    y <- y[order(y$child_name),, drop=FALSE]
    rownames(y) <- NULL
    y
  })
  
  ref.ext <- do.call(rbind, ref.ext)
  rownames(att.ext) <- NULL
  
  col <- lapply(class.name, function(x) {
    y <- model[[x]][["collections"]]
    if(length(y)==0){
      z <- data.frame(matrix(character(0), 0, 2,dimnames=list(NULL,
                                                              c("name", "referencedType"))))
    } else {
      z1 <- names(y)
      z2 <- sapply(y, function(ye) ye[["referencedType"]])
      z <- data.frame(name=z1, referencedType=z2)
    }
    z
  })
  names(col) <- class.name
  
  col.ext <- rep(list(NULL), length(class.name))
  
  col.ext <- lapply(class.name, function(x) {
    ext <- colnames(igr.sp)[which(is.finite(igr.sp[x, ]))]
    y <- unique(do.call(rbind, col[ext]))
    y <- cbind(class=rep(x, nrow(y)), y, stringsAsFactors=FALSE)
    colnames(y) <- c("type", "child_name", "child_type")
    y <- y[order(y$child_name),, drop=FALSE]
    rownames(y) <- NULL
    y
  })
  col.ext <- do.call(rbind, col.ext)
  rownames(col.ext) <- NULL
  res <- rbind(att.ext, ref.ext, col.ext)
  rownames(res) <- NULL
  res <- sqldf("select * from res order by type, child_type")
  res
}

# Retrieve HumanMine model
model = try(getModel.modified(im = im))
head(model)

```

## Modyfing Existing Template Query

Now let's try to modify the existing template query "Gene_Orth" of the HumanMine:

```{r modifying_query}
# Modify query

# Edit a constraint
queryGeneOrth$where[[1]][["value"]]
# Initial value is: "PPARG"

# Change with ABO gene
queryGeneOrth$where[[1]][["value"]] = "ABO"
queryGeneOrth$where[[1]]

# Run query
resGeneOrth <- runQuery(im, queryGeneOrth)
head(resGeneOrth)

# Add a new constraint to remove H. sapiens results
newConstraint <-list(
  path=c("Gene.homologues.homologue.organism.shortName"), 
  op=c("!="), 
  value=c("H. sapiens"), 
  code=c("B")
)

queryGeneOrth$where[[2]] <- newConstraint

# Run query
resGeneOrth = runQuery(im, queryGeneOrth) 
head(resGeneOrth)

# Remove new constraint and run query again
queryGeneOrth$where[[2]] <- NULL

resGeneOrth = runQuery(im, queryGeneOrth)
head(resGeneOrth)

# Add a new column
model[which(model$type=="Homologue"),]
model[which(model$type=="DataSet"),]

# Check length
length(queryGeneOrth$select)

# add output column
queryGeneOrth$select[[6]] = "Gene.homologues.dataSets.name"

# Run query
resGeneOrth = runQuery(im, queryGeneOrth) 
head(resGeneOrth)

# Change constraint logic
queryGeneOrth$constraintLogic <- "A or B"

# Run query
resGeneOrth = runQuery(im, queryGeneOrth) 
head(resGeneOrth)
tail(resGeneOrth)

# Change constraint logic to its original form!
queryGeneOrth$constraintLogic <- "A and B" 

```

## InterMineR.pdf tutorial Recipes

### 3.1 Obtain the gene ontology (GO) terms associated with gene ABO

```{r run_recipe_3.1}

# 3. Recipes
# 3.1 Obtain the gene ontology (GO) terms associated with gene ABO

# Define query
queryGeneGO = getTemplateQuery(
  im,
  name = "Gene_GO"
)

# Assign gene name
queryGeneGO$where[[1]]$value = "ABO"

queryGeneGO$select = queryGeneGO$select[2:5]

# Run query
resGeneGO = runQuery(
  im = im,
  qry = queryGeneGO
)
head(resGeneGO)
```

### 3.2 Obtain the genes associated with gene ontology (GO) term ”metal ion binding”

```{r run_recipe_3.2}
# 3.2 Obtain the genes associated with gene ontology (GO) term ”metal ion binding”

# Start with the template GOterm_Gene (correct Gene GO in manual!)
queryGOterm_Gene = getTemplateQuery(im, "GOterm_Gene")

# Modify the view to display a compact view
queryGOterm_Gene$select = queryGOterm_Gene$select[2:5]

# Modify the constraints to look for GO term "metal ion binding"
queryGOterm_Gene$where[[1]]$value = "metal ion binding"

# Run query
resGOterm_Gene = runQuery(
  im = im,
  qry = queryGOterm_Gene
)

head(resGOterm_Gene)
```

### 3.3 Find and plot the genes within 50000 base pairs of gene ABCA6

```{r run_recipe_3.3}
# Find and plot the genes within 50000 base pairs of gene ABCA6
queryGeneLoc = getTemplateQuery(im, "Gene_Location")
queryGeneLoc$where[[2]][["value"]] = "ABCA6"
resGeneLoc= runQuery(im, queryGeneLoc)

resGeneLoc

# 3.3 Find and plot the genes within 50000 base pairs of gene ABCA6

# Define a new query
queryNeighborGene = newQuery()

# Set the columns for output
queryNeighborGene$select = c("Gene.primaryIdentifier", 
                             "Gene.symbol",
                             "Gene.chromosome.primaryIdentifier",
                             "Gene.locations.start", 
                             "Gene.locations.end", 
                             "Gene.locations.strand")
queryNeighborGene$select

# Define the constraints
newConstraint1 =list(
  path=c("Gene.chromosome.primaryIdentifier"), 
  op=c("="),
  value=c(resGeneLoc[1, "Gene.chromosome.primaryIdentifier"]), 
  code=c("A")
)
newConstraint2 =list(
  path=c("Gene.locations.start"), op=c(">="),
  value=c(as.numeric(resGeneLoc[1, "Gene.locations.start"])-50000),
  code=c("B"))
newConstraint3 =list(
  path=c("Gene.locations.end"), op=c("<="),
  value=c(as.numeric(resGeneLoc[1, "Gene.locations.end"])+50000), code=c("C"))
newConstraint4 =list(
  path=c("Gene.organism.name"), op=c("="), value=c("Homo sapiens"), code=c("D")
)

queryNeighborGene$where =list(
  newConstraint1, 
  newConstraint2, 
  newConstraint3,
  newConstraint4
)

# Define the sort order
queryNeighborGene$orderBy = "Gene.locations.start asc"

# Run the query
resNeighborGene = runQuery(im, queryNeighborGene)
resNeighborGene

# Plot the genes
resNeighborGene$Gene.locations.strand[which(resNeighborGene$Gene.locations.strand==1)]="+"

resNeighborGene$Gene.locations.strand[which(resNeighborGene$Gene.locations.strand==-1)]="-"

gene.idx = which(nchar(resNeighborGene$Gene.symbol)==0)

resNeighborGene$Gene.symbol[gene.idx]=resNeighborGene$Gene.primaryIdentifier[gene.idx]
```

```{r load_Gviz, warning=FALSE, message=FALSE}
require(Gviz)
```

```{r plot_neighbor_genes}
annTrack = AnnotationTrack(
  start=resNeighborGene$Gene.locations.start,
  end=resNeighborGene$Gene.locations.end,
  strand=resNeighborGene$Gene.locations.strand,
  chromosome=resNeighborGene$Gene.chromosome.primaryIdentifier[1],
  genome="GRCh38", 
  name="around ABCA6",
  id=resNeighborGene$Gene.symbol)

#plotTracks(annTrack, shape="box", showFeatureId=T, fontcolor="black")

gtr <- GenomeAxisTrack()
itr <- IdeogramTrack(genome="hg38", chromosome="chr17")
plotTracks(list(gtr, annTrack), shape="box", showFeatureId=T, fontcolor="black")

```

## SessionInfo

```{r sessionInfo}
sessionInfo()
```

